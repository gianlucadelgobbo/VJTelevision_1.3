package FLxER.core {	import flash.display.Sprite;	import flash.events.*;	import flash.net.*;	import flash.xml.*;	import flash.utils.*;	import flash.display.Loader;	import FLxER.main.Rett;	//import FLxER.comp.ButtonRett;	import FLxER.core.Player;	public class Monitor extends Sprite {		var nCh:uint;		public var fondo:Rett;		public var levels:Object;		public var w:uint;		public var h:uint;		//		public var n_play:uint;		var c:uint;		var myAction:Array;		public var mon:Sprite; 		var out:Boolean;		var sending_lc;		var myMask;		public var myloaded:Boolean; 		public function Monitor(xx:Number, yy:Number, ww:uint, hh:uint, n:uint, o:Boolean):void {			myloaded = false;			Preferences.pref.monitorTrgt = this;			Preferences.pref.nLoadErr = new Object();			Preferences.pref.currentMedia = new Object();			x = xx;			y = yy;			w = ww;			h = hh;			out = o;			//scaleX = scale;			//scaleY = scale;			nCh = n;			//fondo = new Rett(0,0,w,h,0xFFFFFF ,null,1);			fondo = new Rett(0,0,w,h,Preferences.pref.myCol.monCol,-1,1);			this.addChild(fondo);			if (out) this.addEventListener(MouseEvent.MOUSE_DOWN,myDrag);			this.buttonMode = false;			this.mouseChildren = true;			mon = new Sprite();			this.addChild(mon);			myMask = new Rett(0,0,w,h,Preferences.pref.myCol.monCol,-1,1);			this.addChild(myMask);			this.mon.mask = myMask;			/**/			levels = new Object();			//fondo.mouseUpAcivation(myDragStop);			//_root.myClassedMC(FLxER.comp.button, this, "fondo", {x:0, y:0, w:400, h:300, fnzTrgt:this, fnz:"myDrag", fnzRelease:"myDragStop", alt:alt});			/*this.createEmptyMovieClip("mon", this.getNextHighestDepth());			_root.mdf.drawer(this, "mask", 0, 0, 400, 300, 0xFFFFFF, null);			this.setMask(this["mask"]);*/			for (var a=0; a<Preferences.pref.nCh; a++) {				//trace("bella")				levels["ch_"+a] = new Player(a,w,h);				this.mon.addChild(levels["ch_"+a]);			}			n_play = 0;			if (out) {				switch (Preferences.pref.myMode) {					case 1 :					sending_lc = new LocalConnection();					break;				}			}		}		public function initHandlerSWF(e:Loader,ch:uint):void {		}		public function initHandlerFLV(event:Event,ch:uint):void {			if (event.info.code == "NetStream.Play.Stop") {				myloaded = false;				levels["ch_"+Preferences.pref.ch].myDuration = undefined;				Preferences.pref.interfaceTrgt.chCnt["ch_"+Preferences.pref.ch].myFileSel.scrolla(1)				Preferences.pref.interfaceTrgt.chCnt["ch_"+Preferences.pref.ch].myFileSel.seleziona(0);			}			if (event.info.code == "NetStream.Play.Start") {				if (!Preferences.pref.interfaceTrgt.hasEventListener(Event.ENTER_FRAME)) {					trace("SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS")					Preferences.pref.tipo = "flv";					Preferences.pref.interfaceTrgt.avvia_indice()				}			}			if (event.info.code == "NetStream.Play.StreamNotFound" || event.info.code == "NetStream.Play.FileStructureInvalid"|| event.info.code == "NetStream.Play.NoSupportedTrackFound") {			}		}		public function initHandlerMP3(ch:uint):void {		}		public function initHandlerJPG(e:Loader,ch:uint):void {		}		public function errorHandlerCNT(event:Event,ch:uint):void {			trace("errorHandlerCNT ")			trace("errorHandlerCNT "+Preferences.pref.flxerPref.childNodes[0].childNodes[1].attributes.useServer)			trace("errorHandlerCNT "+Preferences.pref.currentMedia["ch_"+ch])			if (Preferences.pref.nLoadErr["ch_"+ch]<1 && Preferences.pref.flxerPref.childNodes[0].childNodes[1].attributes.useServer == "true") {				Preferences.pref.nLoadErr["ch_"+ch]++;				var u = Preferences.pref.flxerPref.childNodes[0].childNodes[1].attributes.value+Preferences.pref.currentMedia["ch_"+ch];				Preferences.pref.interfaceTrgt.chCnt["ch_"+ch].myLoadMovieMore(u,u)			} else {				Preferences.pref.interfaceTrgt.chCnt["ch_"+ch].loadErr();			}		}		public function errorHandlerSWF(event:Event,ch:uint):void {			errorHandlerCNT(event,ch);		}		public function errorHandlerMP3(event:Event,ch:uint):void {			errorHandlerCNT(event,ch);		}		public function errorHandlerJPG(event:Event,ch:uint):void {			errorHandlerCNT(event,ch);			trace("errorHandlerJPG "+Preferences.pref.currentMedia["ch_"+ch])			/*			if (Preferences.pref.nLoadErr["ch_"+ch]<1 && Preferences.pref.flxerPref.childNodes[0].childNodes[1].attributes.useServer == "true") {				Preferences.pref.nLoadErr["ch_"+ch]++;				if (this.imgLoader0.content == null) {					imgLoader0.contentLoaderInfo.addEventListener(Event.INIT, initHandlerJPG);					imgLoader0.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandlerJPG);					imgLoader0.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandlerJPG);					imgToShow = this.imgLoader0;					imgLoader0.load(Preferences.pref.flxerPref.childNodes[0].childNodes[1].attributes.value+Preferences.pref.currentMedia["ch_"+ch]);				} else {					imgLoader1.contentLoaderInfo.addEventListener(Event.INIT, initHandlerJPG);					imgLoader1.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandlerJPG);					imgLoader1.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandlerJPG);					imgToShow = this.imgLoader1;					imgLoader1.load(Preferences.pref.flxerPref.childNodes[0].childNodes[1].attributes.value+Preferences.pref.currentMedia["ch_"+ch]);				}			} else {				Preferences.pref.monitorTrgt.myError(ch,"FILE NOT FOUND", "media", currentMedia);			}			*/		}		public function errorHandlerWipes(event:Event, ch:uint):void {		}		//		public function resizer(ww:uint, hh:uint):void {			w = ww;			h = hh;			myMask.width = fondo.width = w;			myMask.height = fondo.height = h;			for (var a=0; a<Preferences.pref.nCh; a++) {				levels["ch_"+a].resizer(ww, hh);			}					}		public function mbuto(azione:String):void {			trace("MMmbuto"+azione);			trace("MMmbuto"+Preferences.pref.myPreviewActive);			if (Preferences.pref.recStatus) {				var tmp = new XMLDocument("<r>"+azione+"</r>");				trace(Preferences.pref.myGlobalCtrl.myRecorder.myLiveset)				Preferences.pref.myGlobalCtrl.myRecorder.myLiveset.childNodes[0].appendChild(tmp.childNodes[0]);				trace(Preferences.pref.myGlobalCtrl.myRecorder.myLiveset)				Preferences.pref.lastTime = getTimer();			}			/*			if (Preferences.pref.myGlobalCtrl.myRecorder.broadcastStatus && this.parent == _root) {				var tmp = "<r>"+azione+"</r>";				Preferences.pref.myGlobalCtrl.myRecorder.myRemote_so.data[Preferences.pref.myGlobalCtrl.myRecorder.broadName] = tmp;				Preferences.pref.myGlobalCtrl.myRecorder.last_time = getTimer();			}*/			if (out) {				switch (Preferences.pref.myMode) {					case 1 :					sending_lc.send("lc_flxer", "mbuto", azione);					break;					case 2 :					parent.myFlxerSSConnectorSender.socketBroad.send(azione);					break;				}			}			if (Preferences.pref.myPreviewActive) {				myAction = azione.split(",");				levels["ch_"+myAction[2]][myAction[1]](myAction);				Preferences.pref.lastTime = getTimer();			}		}		function myDrag(event:Event):void {			stage.addEventListener(MouseEvent.MOUSE_UP,myDragStop);			if (Preferences.pref.interfaceTrgt.chCnt["ch_"+Preferences.pref.ch].lockWipeStatus) {				levels["ch_"+Preferences.pref.ch].startDrag();			} else {				levels["ch_"+Preferences.pref.ch].vid.startDrag();			}			if (out) stage.addEventListener(MouseEvent.MOUSE_MOVE,updateOut);		}		function myDragStop(event:Event):void {			if (out) stage.removeEventListener(MouseEvent.MOUSE_MOVE,updateOut);			stage.removeEventListener(MouseEvent.MOUSE_UP,myDragStop);			stopDrag();		}		function updateOut(event:Event):void {			Preferences.pref.interfaceTrgt.chCnt["ch_"+Preferences.pref.ch].myTrasform.updateOnDrag();			if (out) {				switch (Preferences.pref.myMode) {					case 1 :					trace("MMmbuto");					var az = (getTimer()-Preferences.pref.lastTime)+",chMove,"+Preferences.pref.ch+","+levels["ch_"+Preferences.pref.ch].x+","+levels["ch_"+Preferences.pref.ch].y+","+levels["ch_"+Preferences.pref.ch].vid.x+","+levels["ch_"+Preferences.pref.ch].vid.y;					sending_lc.send("lc_flxer", "mbuto", az);					break;				}			}		}		public function stop_liveset():void {			clearInterval(c)		}		public function play_liveset():void {			var tmp2 = Preferences.pref.myGlobalCtrl.myRecorder.myLiveset.childNodes[0].childNodes[this.n_play].childNodes[0].toString().split(",");			c = setInterval(play_liveset_int, parseInt(tmp2[0]));		}		function play_liveset_int():void {			clearInterval(c);			mbuto(Preferences.pref.myGlobalCtrl.myRecorder.myLiveset.childNodes[0].childNodes[this.n_play].childNodes[0].toString());			if (this.n_play<Preferences.pref.myGlobalCtrl.myRecorder.myLiveset.childNodes[0].childNodes.length-1) {				this.n_play++;				play_liveset();			} else {				this.n_play = 0;				for (var a=0; a<Preferences.pref.nCh; a++) {					levels["ch_"+a].eject(null);				}								if (Preferences.pref.myGlobalCtrl.myRecorder.loopStatus) {					play_liveset();				}			}		}	}}